%%%%%%%%%%%%%%%%%%%%% chapter.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% sample chapter
%
% Use this file as a template for your own input.
%
%%%%%%%%%%%%%%%%%%%%%%%% Springer-Verlag %%%%%%%%%%%%%%%%%%%%%%%%%%
%\motto{Use the template \emph{chapter.tex} to style the various elements of your chapter content.}
\chapter{Week 3}
\label{intro3} % Always give a unique label
% use \chaptermark{}
% to alter or adjust the chapter heading in the running head

%\textbf{una conclusion}
%\textit{una recomendacion}

\section{Introduction to GitHub} \label{W301}

	\subsection{Intro to Module3: Working with Remotes} \label{W301a}

	Welcome back. Up until now we've learned a lot of interesting and complex techniques on how to use Git locally. We started with the very basic Git workflow for modifying files staging the changes and then committing them. We then looked at other things we can do with Git, like deleting or renaming files, getting more information about commits or skipping the staging area altogether. Next, we saw how to undo staged, unstaged or committed changes in our Git repositories. Finally, we learned a bit about how to work with different branches, how to merge changes from separate branches. That's a lot of complex stuff and it's natural that it might seem scary. But it can also be very satisfying once you start to understand what's going on and just think of how valuable these new skills will be as you advance your IT career. 
	So remember that you can review the material as many times as needed and that the best way to master it is to keep practicing on your own, and if something is still unclear after that, don't forget you can use the discussion forums to ask for help. 
	
	In this module, we'll learn a load of new things related to GitHub and remote repositories. We'll first talk about what GitHub is and why it matters, and then we'll dive into how to work with GitHub and other remote repositories. Being able to use remote repositories allows us to effectively collaborate with others. Our collaborators can be sitting in the same office as we are or they can be thousands of miles away on a different continent working at a different time of day. Using a version control system like Git lets us incorporate the work of different people no matter where they are or when they're working. I've personally had a bunch of interesting experiences collaborating through a version control system. One that stands out was a debugging session a friend and I had while at work. I was working on some tricky code and I couldn't figure out the best way to implement a function. I was stuck and ready to give up completely. My colleague suggested that I work on another piece of the file further down while he figured out the optimal solution for the code that I was having trouble with. This was a super seamless experience and was only possible because of a VCS, and the superpower of teamwork of course. By the end of the module you'll be able to collaborate with friends and colleagues just like I did. Let's get to it.

	\subsection{What is GitHub} \label{W301b}

	Git is a \textit{distributed} VCS (version control system). Distributed means that each developer has a copy of the whole repository on their local machine.
	
	Each copy is a peer of the others. But we can \textit{host} one of these copies on a server and then use it as a \textit{remote repository} for the other copies. This lets us synchronize work between copies through this server. Any of us can create a Git server like this one, and many companies have similar internal services. But if you don't want to set up a Git server yourself and host your repositories, you can use an online service like \textit{GitHub}.
	
	GitHub is a web-based Git repository hosting service. On top of the version control functionality of Git, GitHub includes extra features like \textit{bug tracking}, \textit{wikis}, and \textit{task management}. GitHub lets us share and access repositories on the web and copy or clone them to our local computer, so we can work on them. GitHub is a popular choice with a robust feature set, but it's not the only one. Other services that provide similar functionality are \textit{BitBucket}, and \textit{GitLab}.
	
	
	For the rest of this course, we'll be using GitHub for our examples. But feel free to use the tool that best fits your needs. GitHub provides free access to a Git server for public and private repositories. It \textit{limits the number of contributors for the free private repositories}, and offers an unlimited private repository service for a monthly fee. We'll be using a free repository for our examples, which is fine for educational use, small personal projects, or open source development.
	
	A word of caution on how you can manage these repos though. If hackers get hold of information about your organization's IT infrastructure, they can use it to try and break into your network. So make sure you treat this information as confidential. \textbf{For real configuration and development work, you should use a secure and private Git server, and limit the people authorized to work on it}.
	
	To use GitHub,\textit{ the first thing you need to do is create an account} if you don't have one already. Signing up online is free and relatively simple. Once you've done that, you can either create your own repos or contribute to repos from other projects. If you don't have a GitHub account yet, now is a good time to create one. Visit \verb|github.com| to sign up for their service. Once you've done that, meet me over in the next video, where we'll go over some basic interactions with GitHub.

	\subsection{Basic Interaction with GitHub} \label{W301c}

	As we called out, GitHub is an online service. To use it, you first need to create an account on the site. Once you have your account, you're ready to create your brand new repository on GitHub. Let's do this now. Going step-by-step.
	
	We'll start by clicking the \verb|Create a repository| link on the left. This will take us to the repo creation wizard. The wizard is pretty straightforward. The first thing we need to do is give a name for our repo. We'll call this repo \textit{health checks}. After that comes a description of what the repo will be used for. We'll say that'll be used for \texttt{scripts that check the health of our computers}. Then we need to select whether we want the repo to be \texttt{public} or \texttt{private}. We'll go with private for now. 
	Finally, the wizard can help us get started with some few initialization files like a \verb|README|, a \verb|gitignore|, or license file. We'll go with just the \verb|README| for now, and then create the repo. 
	Using the wizard, we created the repo and have a fresh remote repository ready to go. Just like magic. 
	
	Let's get to work. First step is to create a local copy of the repository. 
	We'll do that by using the \texttt{git clone} command followed by the \texttt{URL} of the repo. 
	GitHub conveniently lets us copy the URL from our repo from the interface so that we don't have to type it (Fig. \ref{W301c-clone}).
	
	\begin{figure} 
		\caption{Clone with HTTPS window.}
		\centering
		\includegraphics[scale=0.25]{W301c-clone.png}
		\label{W301c-clone}
	\end{figure}
	
	We're now ready to clone the repo into our computer. We'll do that by calling git clone and paste in the URL we copied. To do this, GitHub will ask for our username and password (Fig. \ref{W301c-clone2}).
	
	\begin{figure} 
		\caption{Console \texttt{git clone URL}.}
		\centering
		\includegraphics[scale=0.25]{W301c-clone2.png}
		\label{W301c-clone2}
	\end{figure}
	
	Just like that, we've downloaded a copy of the remote repository from GitHub onto the local machine. This means that we can perform all the git actions that we've learned up till now. Since the repo is called \verb|health-checks|, \textbf{a directory with that name was automatically created for us and now has the working tree of the Repository in it}. So let's change that directory and look at the contents using \verb|cd health-checks/| and then \verb|ls -l|. Our repo is basically empty. It only has the \verb|README| file that GitHub created for us. This file is in a special format called \texttt{markdown}. Let's add a bit more content to it writing \texttt{This repo will be populated with lots of fancy checks}. 
	
	We've changed this file. What do we need to do now? We need to stage the change and committed. We've seen a couple of different ways to do that. Let's use our shortcuts to do this in just one command:
	
	\verb|git commit -a -m "Add one more line to README.md"|. 
	
	Okay. We've modified our \verb|README| file. But we've seen all this before. We got to remote repository set up on GitHub. So let's use it. We can send our changes to that remote repository by using the \verb| git push| command which will gather all the snapshots we've taken and send them to the remote repository. In this case, we've only taken one snapshot. We'll talk more about what's going on behind the scenes with git push and remote repositories in later videos. But the mechanics are pretty simple. To push our modified \verb|README| up to GitHub, we'll just call git push (Fig. \ref{W301c-push}).
	
	\begin{figure} 
		\caption{git push.}
		\centering
		\includegraphics[scale=0.25]{W301c-push.png}
		\label{W301c-push}
	\end{figure}
	
	Once again, we're asked for our password. After that, we see a bunch of messages from git related to the push. When we access our project, we see the contents of the \verb|README| file. So if we check our repository on GitHub, we should see the updated message (Fig. \ref{W301c-push2}).
	
	\begin{figure} 
		\caption{Updated README file.}
		\centering
		\includegraphics[scale=0.25]{W301c-push2.png}
		\label{W301c-push2}
	\end{figure}
	
	Pretty cool, right? We've taken the local changes on our computer and pushed them out to a remote repository hosted on GitHub. 
	
	You've probably noticed that we had to enter our password both when retrieving the repo and when pushing changes to the repo. There are a couple ways to avoid having to do this. One way is to create an \textit{SSH key pair} and store the public key in our profile so that GitHub recognizes our computer. Another option is to \textit{use a credential helper} which caches our credentials for a time window so that we don't need to enter our password with every interaction. Git already comes with a credential helper baked in. We just need to enable it. We do that by calling: 
	
	\verb| git config --global credential.helper cache |
	
	Now that we've enabled the credential helper, we'll need to enter our credentials once more. After that, they'll be cached for 15 minutes. 
	To check this, we can try another git command, \verb|git pull| which is the command we use to \textit{retrieve new changes from the repository}. We'll enter our credentials on the first call to the command and they'll be cached, so we won't need to enter them again.
	
	\begin{verbatim}
		$ git pull
		Already up to date.
	\end{verbatim}
	
	With that, we've seen how to create repositories on GitHub, \textit{clone our remote repository, push changes to it, and pull changes from it}. There's a lot going on behind the scenes here and we'll dive deeper into the details and more collaboration techniques in later videos. For now, check out the next reading for a summary of this basic workflow. Then there's a quick quiz to make sure this is making sense.


	\subsection{Reading: Basic Interaction with GitHub} \label{W301d}
	
	\begin{table}
		\caption{Cheat-sheet}
		\label{tab:W301d}       % Give a unique label
		%
		% For LaTeX tables use
		%
		\begin{tabular}{p{3cm}p{8cm}}
			\hline\noalign{\smallskip}
			Command & Explanation \\
			\noalign{\smallskip}\svhline\noalign{\smallskip}
			git clone URL & used to clone a remote repository into a local workspace \\
			git push & used to push commits from your local repo to a remote repo \\
			git pull & used to fetch the newest updates from a remote repository \\
			\noalign{\smallskip}\hline\noalign{\smallskip}
		\end{tabular}
	\end{table}
	%
	This can be useful for keeping your local workspace up to date.
	
	\begin{itemize}
		\item https://help.github.com/en/articles/caching-your-github-password-in-git
	
		\item https://help.github.com/en/articles/generating-an-ssh-key  
		
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Using a Remote Repository} \label{W302}

	\subsection{What is a remote?} \label{W302a}
	When we \textit{clone} the newly created GitHub repository, we had our local Git Repo interact with a remote repository. 
	Remote repositories are a big part of the distributed nature of Git collaboration. 
	It let lots of developers contribute to a project from their own workstations making changes to local copies of the project independently of one another. 
	When they need to share their changes, they can issue git commands to \textit{pull code from a remote repository} or \textit{push code into one}. 
	
	There are a bunch of ways to host remote repositories. As we called out, there is many internet-based Git hosting providers like GitHub, BitBucket or GitLab which offer similar services. We can also set up a Git server on our own network to host private repositories. 
	A locally hosted Git server can run on almost any platform including Linux, mac OS, or Windows. This has benefits like increased privacy, control, and customization. 
	
	To understand remote repositories, and Git's distributed nature a bit better, imagine you're working together with some friends to design a computer game, each of you has a different portion of the game you're responsible for. 
	One person is designing the levels, another the characters while others are writing the code for the graphics, physics, and gameplay. 
	All these areas will have to come together into a single place for the final product. Although your friends might work on their parts by themselves, from time to time, everyone needs to send out progress updates to let each other know what they've been working on. You will then need to combine their work into your own portion of the project to make sure it's all compatible. Using Git to manage a project helps us collaborate successfully. 
	Everyone will develop their piece of the project independently in their own local repositories maybe even using separate branches. Occasionally they'll push finished code into a central remote repository where others can pull it and incorporate it into their new developments. So how does this work? 
	
	Alongside the local development branches like master, Git keeps copies of the commits that have been submitted to the remote repository and separate branches. 
	\textit{If someone has updated a repository since the last time you synchronize your local copy, Git will tell you that it's time to do an update}. 
	If you have your own local changes when you pull down the code from the remote repo, you might need to fix merge conflicts before you can push your own changes. 
	In this way Git let's multiple people work on the same project at the same time. When pulling new code it will merge the changes automatically if possible or will tell us to manually perform the integrating if there are conflicts. 
	So when working with remotes the workflow for making changes has some extra steps. 
	Will still modify stage and commit our local changes. After committing, we'll \texttt{fetch} any new changes from the remote repo manually \texttt{merge} if necessary and only then will push our changes to the remote repo. 
	
	Git supports a variety of ways to connect to a remote repository. Some of the most common are using the \verb|HTTP|, \verb|HTTPS| and \verb|SSH| protocols and their corresponding URLs. 
	HTTP is generally used to allow\textit{ read only access to a repository}. In other words, it lets people clone the contents of your repo without letting them push new contents to it. 
	Conversely HTTPS and SSH, both provide methods of authenticating users so you can control who \textit{gets permission to push}. If all this protocol talk is making your head spin you might want to review the video on the subjects made by my colleague Gian. You'll find the link to this in the next reading.
	
	The distributed nature of the work means that\textit{ there are no limits to how many people can push code into a repository}.
	It's a good idea to control who can push codes to repos and to make sure you give access only to people you trust. Web services like GitHub, offer a bunch of different mechanisms to control access to Repositories. Some of these are available to the general public while others are only available to enterprise users. By now you have an idea of what a remote repository is and how it interacts with local Git repositories. Up next, we'll dive into some of the commands that let us interact with remotes.

	\subsection{Working with Remotes} \label{W302b}

	When we call a \verb|git clone| to get a local copy of a remote repository, Git sets up that remote repository with the default origin name. We can look at the configuration for that remote by running \verb|git remote -v| in the directory of the repo. 
	Here we see the URLs associated with the origin remote. There are two URLs (\ref{W302b-remote}). 
	
	\begin{figure} 
		\caption{git remote -v.}
		\centering
		\includegraphics[scale=0.25]{W302b-remote.png}
		\label{W302b-remote}
	\end{figure} 
	
	One will be used to fetch data from the remote repository, and the other one to push data to that remote repo
	\textit{They'll usually point at the same place}. But in some cases, you can have the \texttt{fetch URL} use HTTP for read only access, and the \texttt{push URL} use HTTPS or SSH for access control. This is fine as long as the contents of the repo that you read when fetching are the same that you write to in pushing. \textit{Remote repositories have a name assigned to them}, by default, the assigned name is \verb|origin|. This lets us track more than one remote in the same Git directory.
	
	While this is not the typical usage, it can be useful when collaborating with different teams on projects that are related to each other. We won't look at how to do that here, but we'll include a link for more information in the next reading. If we want to get even more information about our remote, we can call \verb|git remote show origin| (Fig. \ref{W302b-remote2}).
	
	\begin{figure} 
		\caption{\texttt{git branch -r}.}
		\centering
		\includegraphics[scale=0.25]{W302b-remote2.png}
		\label{W302b-remote2}
	\end{figure}
	
	There's a ton of information here, and we don't need all of it right now. We can see the \texttt{fetch} and \texttt{push URL}s that we saw before, and the \texttt{local} and \texttt{remote} branches too.
	
	For now \textit{we only have a master branch that exists locally and remotely}. So the information here seems a bit repetitive. Once you start having\textit{more branches}, especially different branches in the local and remote repo, this information starts becoming more complex.
	
	So what are these \textit{remote branches} that we're talking about anyways?
	
	Whenever we're operating with remotes, Git uses remote branches to keep copies of the data that's stored in the remote repository. We could \textbf{have a look at the remote branches that our Git repo is currently tracking by running} \verb|git branch -r| (Fig. \ref{W302b-remoteBranches}).
	
	\begin{figure} 
		\caption{git remote show origin.}
		\centering
		\includegraphics[scale=0.25]{W302b-remoteBranches.png}
		\label{W302b-remoteBranches}
	\end{figure}
	
	These branches are read only. We can look at the commit history, like we would with local branches, but we can't make any changes to them directly. 
	
	To modify their contents, we'll have to go through the workflow we called out before.
	First, we pull ( \verb|git pull| ) any new changes to our local branch, then merge them with our changes and push ( \verb|git push| ) our changes to the repo.
	Remember how we've been using (\verb|git status|) to check the status of our changes? We can also use \verb|git status| to check the status of our changes in remote branches as well.
	
	\begin{verbatim}
		$ git status
		On branch master
		Your branch is up to date with 'origin/master'.
		
		nothing to commit, working tree clean
	\end{verbatim}
	
	Now that we're working with a remote repository, git status gives us additional information. \textit{It tells us that our branch is up to date with the origin/master branch} (Fig. \ref{W302b-status}), which means that the \texttt{master} \textbf{branch in the remote repository called} \texttt{origin}, \textbf{has the same commits as our} \texttt{local master} \textbf{branch}. But \textit{what if it wasn't up to date?}.
	
	\begin{figure} 
		\caption{git status.}
		\centering
		\includegraphics[scale=0.25]{W302b-status.png}
		\label{W302b-status}
	\end{figure}


	\subsection{Fetching New Changes} \label{W302c}

	While we were learning about remotes, our colleague \textit{Blue Kale added some files to our repo}. We could always use the GitHub website to browse the changes that were submitted. But we want to learn \textit{how to do it by interacting through the command line} because you might need to do it this way at your job, and it'll work the same no matter which platform you use to interact with Git. So first, let's look at the output of the \verb|git remote show origin command| (Fig. \ref{W302c-remoteShow}).
	
	\begin{figure} 
		\caption{git remote show origin.}
		\centering
		\includegraphics[scale=0.25]{W302c-remoteShow.png}
		\label{W302c-remoteShow}
	\end{figure}
	
	
	Check out how it says that the \textbf{local branches out of date}. This happens when\textit{ there were commits done to the repo that aren't yet reflected locally}. Git doesn't keep remote and local branches in sync automatically, it waits until we execute commands to move data around when we're ready. To sync the data, we use the \verb|git fetch| command. This command \textit{copies the commits done in the remote repository to the remote branches}, so we can see what other people have committed. Let's call it now and see what happens.
	
	\begin{figure} 
		\caption{git fetch.}
		\centering
		\includegraphics[scale=0.25]{W302c-fetch.png}
		\label{W302c-fetch}
	\end{figure}
	
	Fetched content\textbf{ is downloaded to the remote branches on our repository}. So \textbf{it's not automatically mirrored to our local branches}. We can run \verb|git checkout| on these branches to see the working tree, and we can run \verb|git log| to see the commit history. Let's look at the current commits in the remote repo by running \verb|git log origin/master|.
	
	\begin{figure} 
		\caption{git log origin/master.}
		\centering
		\includegraphics[scale=0.25]{W302c-log.png}
		\label{W302c-log}
	\end{figure}
	
	Looking at this output, we can see that the \textbf{remote origin/branch is pointing to the latest commit} (\verb|commit b62d...|). While the \textbf{local master branch is pointing to the previous commit} (\verb|commit 807c...|) we made earlier on. Let's see what happens if we run \verb|git status| now. 
	
	\begin{figure} 
		\caption{git status.}
		\centering
		\includegraphics[scale=0.25]{W302c-status.png}
		\label{W302c-status}
	\end{figure}
	
	Git status helpfully tells us that \textbf{there's a commit that we don't have in our branch}. It does this by letting us know our branches behind their remote \texttt{origin/master} branch. 
	If we want to integrate the branches into our \texttt{master} branch, we can perform a \verb|merge| operation, which merges the \verb|origin/master| branch into our \verb|local master| branch. To do that, we'll call \verb|git merge origin/master|.
	
	\begin{figure} 
		\caption{git merge origin/master.}
		\centering
		\includegraphics[scale=0.25]{W302c-merge.png}
		\label{W302c-merge}
	\end{figure}
	
	Great. We've \textit{merged the changes of the master branch of the remote repository into our local branch}. See how Git tells us that the code was integrated using \verb|fast-forward|? It also shows that \textit{two files were added}, 
	\verb|all_checks| and \verb|disk_usage.py|. 
	
	If we look at the log output on our branch now, we should see the new commit. We see that now our \verb|master| branch is \textit{up to date with} the \verb|remote origin/master| branch. With that, \textit{we've updated our branch to the latest changes}.
	
	\begin{figure} 
		\caption{git merge origin/master.}
		\centering
		\includegraphics[scale=0.5]{W302c-log2.png}
		\label{W302c-log2}
	\end{figure}
	
	We can use \verb|git fetch| like this to r\textbf{eview the changes that happen in} the \verb|remote| repository. If we're happy with them, we can use \verb|git merge| \textbf{to integrate them} into the \verb|local| branch. Fetching commits from a remote repository and merging them into your local repository is such a common operation in Git that there's a handy command to let us do it all in one action \verb|git pull|. We'll check that out in our next video.

	\subsection{Updating the Local Repository} \label{W302d}

	Earlier, we took a look at the basic workflow for working with remotes when we want to \verb|fetch| the changes manually, \verb|merge| if necessary, and only then push any changes of our own. Since \textbf{fetching and merging are so common, Git gives us the} \verb|git pull| command that does both for us. Running \verb|git pull| will fetch the remote copy of the current branch and automatically try to merge it into the current local branch.
	
	Let's check if our friend Blue Kale has made any new changes to the repo. We'll run \verb|git pull| and see what changes we get.
	
	\begin{figure} 
		\caption{git pull.}
		\centering
		\includegraphics[scale=0.5]{W302d-pull.png}
		\label{W302d-pull}
	\end{figure}
	
	
	If you look closely at this output, you'll see that \textbf{it includes the output of the fetch and merge commands that we saw earlier}. First, Git fetched the updated contents from the remote repository, including a \verb|new branch| called \verb|experimental|. And then it did a \verb|fast forward merge| to the \verb|local master| branch. We'll see that the \verb|all_checks| file was updated as well.
	
	We can look at the changes by using \verb|git log -p -1| (Fig. \ref{W302d-log}).
	
	\begin{figure} 
		\caption{git log -p -1.}
		\centering
		\includegraphics[scale=0.5]{W302d-log.png}
		\label{W302d-log}
	\end{figure}
	
	We see that our colleague added a \verb|check_disk_full| function that includes the code from the other \verb|disk_usage| py file that we saw earlier. 
	So now I'll exit the editor with \verb|q|. When we called \verb|git pull|, we saw that there was also a \verb|new remote| branch called \verb|experimental|. Our friend Blue Kale told us that they've started working on a new feature in that branch. Let's check out the output of \verb|git remote show origin| and see what it says about that \verb|new branch| (Fig. \ref{W302d-remoteShow}).
	
	\begin{figure} 
		\caption{git remote show origin}
		\centering
		\includegraphics[scale=0.5]{W302d-remoteShow.png}
		\label{W302d-remoteShow}
	\end{figure}
	
	We see that there's a new remote branch called \verb|experimental|, which \textit{we don't have a local branch for yet}. \textbf{To create a local branch for it}, we can run \verb|git checkout experimental|.
	
	\begin{figure} 
		\caption{git checkout experimental}
		\centering
		\includegraphics[scale=0.5]{W302d-checkout.png}
		\label{W302d-checkout}
	\end{figure}
	
	When we checked out the experimental branch, Git automatically \textit{copied the contents of the remote branch into the local branch}. The working tree has been updated to the contents of the experimental branch. Now we're all set to work on the experimental feature together with our colleague. 
	
	In this last example, we got the contents of the \verb|experimental branch| together with those of the \verb|master branch| when we called \verb|git pull|, which also merged new changes onto the master branch. If we want to \textit{get the contents of remote branches without automatically merging any contents into the local branches}, we can call \verb|git remote update|. 
	
	This will fetch the contents of all remote branches, so that we can just call \verb|checkout| or \verb|merge| as needed. We've now seen a bunch of different ways that we can use to interact with remote repositories. We've seen how to check their status, how to push and pull changes into repositories, and even how to get new branches out of them. 
	There's still more to come, but you're probably starting to see how useful this can be for collaborating with others.
	
	In our past examples, we've only looked at what happens with changes when they can be solved through \verb|fast forward|. In upcoming videos, we'll look at \textit{what happens when we try to push changes, especially when our changes generate conflicts}. 
	But before we do that, check out the reading for the list of all the commands involved, and then take the quiz to put this knowledge into practice.

	\subsection{Reading: Git Remotes Cheat-Sheet} \label{W302e}

	\begin{table}
		\caption{Cheat-sheet}
		\label{tab:W302e}       % Give a unique label
		%
		% For LaTeX tables use
		%
		\begin{tabular}{p{4cm}p{7.5cm}}
			\hline\noalign{\smallskip}
			Command & Explanation \\
			\noalign{\smallskip}\svhline\noalign{\smallskip}
			\verb|git remote| & List remote repos \\
			\verb|git remote -v| & List remote repos verbosely\\
			\verb|git remote show <name>| & Describes a single remote repo \\
			\verb|git remote update| & Fetches the most up-to-date objects \\
			\verb|git fetch| & Downloads specific objects \\		
			\verb|git branch -r| & Lists remote branches; can be combined with other branch arguments to manage remote branches \\
			\noalign{\smallskip}\hline\noalign{\smallskip}
		\end{tabular}
	\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Solving Conflicts} \label{W303}

	\subsection{The Pull-Merge-Push Workflow} \label{W303a}

	We've now looked at the details of fetching and pulling data from a remote repositories without any local changes. We saw earlier how we can use the \verb|git push| command to send our changes to the remote repo. But \textit{what if when we go to push our changes, there are new changes to the remote repo}? To find out, let's start by making a change to our \verb|all_checks.py| script.
	
	Remember way back to the beginning of the course, when we fixed the bug in the function that checks the disk space? The one that was doing gigabyte conversion twice?
	
	Part of the reason why our code was so buggy, was that \textit{we were passing numbers around without saying what those numbers were for}. We could have made our code clearer by renaming our \verb|min_absolute| parameter to \verb|min_GB|. So that it's obvious that the function expects gigabytes (Fig. \ref{W302e-code}).
	
	\begin{figure} 
		\caption{min\_absolute}
		\centering
		\includegraphics[scale=0.5]{W302e-code.png}
		\label{W302e-code}
	\end{figure}
	
	With that, we've clarified the code of the function (Fig. \ref{W302e-code2}). 
	
	\begin{figure} 
		\caption{min\_gb}
		\centering
		\includegraphics[scale=0.5]{W302e-code2.png}
		\label{W302e-code2}
	\end{figure}
	
	Another way we can make the code invocation clearer, we can use the name of the parameters in the call to the function, like this (Fig. \ref{W302e-code3}).
	
	\begin{figure} 
		\caption{min\_gb}
		\centering
		\includegraphics[scale=0.5]{W302e-code3.png}
		\label{W302e-code3}
	\end{figure}
	
	By using the names of the parameters, our invocation is clear, and we can even alter the order of the values and our code would still work (Fig. \ref{W302e-code4}).
	
	\begin{figure} 
		\caption{min\_gb}
		\centering
		\includegraphics[scale=0.5]{W302e-code4.png}
		\label{W302e-code4}
	\end{figure}
	
	
	All right, we've made the change. Let's stage it and commit it as usual. We'll first use \verb|git add -p| to look at the changes we made and accept them (Fig. \ref{W302e-code5}).
	
	\begin{figure} 
		\caption{min\_gb}
		\centering
		\includegraphics[scale=0.5]{W302e-code5.png}
		\label{W302e-code5}
	\end{figure}
	
	Then we'll create a commit message to show that we've renamed \verb|min_absolute| to \verb|min_GB|, and that we're using parameter names for the invocation.
	We've made our change, staged it, and committed it. \textbf{We should be ready to push into the remote repo, except now we have a collaborator also making changes}. 
	
	Let's see what happens when we try running \verb|git push|. And it failed. Can you work out what went wrong here? (Fig. \ref{W302e-push}).
	
	\begin{figure} 
		\caption{git push rejected}
		\centering
		\includegraphics[scale=0.5]{W302e-push.png}
		\label{W302e-push}
	\end{figure}
	
	There are a few hints. When we tried to push, Git \textbf{rejected} our change, that's because \textbf{the remote repository contains changes that we don't have in our local branch that Git can't fast-forward}. Maybe you remember when we talked about Git's merging algorithms? As usual, Git gives us some helpful information along with the error message, especially the part about integrating remote changes with \verb|git pull|.
	
	This means \textbf{we need to sync our local remote branch with the remote repository before we can push}. We learned earlier that we can do this with \verb|git pull|. Let's do this now. Git tried to automatically merge the local and remote changes to \verb|all_checks.py|, but found a conflict (Fig. \ref{W302e-pull}). 
	
	\begin{figure} 
		\caption{git pull conflict}
		\centering
		\includegraphics[scale=0.5]{W302e-pull.png}
		\label{W302e-pull}
	\end{figure}
	
	
	Let's first look at the tree of commits on all branches as represented by:
	
	\verb|git log --graph --oneline --all| (Fig. \ref{W302e-log}). 
	
	\begin{figure} 
		\caption{git log --graph --oneline --all}
		\centering
		\includegraphics[scale=0.5]{W302e-log.png}
		\label{W302e-log}
	\end{figure}
	
	This graph shows us the different commits and positions in the tree. We can see the master branch, the \verb|origin/master branch|, and the experimental branch. 
	
	The graph indicates that our current commit and the commit in the \verb|origin/master branch| share a common ancestor (\verb|commit 992d659...|), but they don't follow one another.
	This means that we'll need to do a \verb|three-way merge|. To do this, let's look at the actual changes in that commit by running \verb|git log -p origin/master|.
	
	So our colleague decide to reorder the conditional clauses in the function to match the order that the parameters are passed to the function. 
	They happen to change in the same line ( \verb|-| and \verb|+| lines) (Fig. \ref{W302e-log2}) that we changed when we renamed the \verb|min_gb| variable, which caused the conflict that Git couldn't resolve. Let's \textbf{fix it by editing the file to remove the conflict}. So first, let me exit with \verb|q| .
	
	\begin{figure} 
		\caption{git log -p origin/master}
		\centering
		\includegraphics[scale=0.5]{W302e-log2.png}
		\label{W302e-log2}
	\end{figure}
	
	We see that the problem occurred in the conditional (Fig. \ref{W302e-fix}). On the first line, we see our change, where \verb|min_absolute| was renamed to \verb|min_gb|. In the second line, we see the old variable names, with the checks done in a different order.
	
	\begin{figure} 
		\caption{Fixing code}
		\centering
		\includegraphics[scale=0.5]{W302e-fix.png}
		\label{W302e-fix}
	\end{figure}
	
	We need to decide what to do to this. For example, we can keep the new order, but use \verb|min_gb|. One thing to notice is that \textit{Git will try to do all possible automatic merges} and only leave manual conflicts for us to resolve when the automatic merge fails.
	In this case, we can see that the other changes we made were merged successfully without intervention.\textbf{Only the change that happened in the same line of the file needed our input}. 
	
	We fixed the conflict here, and the file is short enough that we can very quickly check that there are no other conflicts.\textit{ For larger files, it might make sense to search for the conflict markers}, \verb|>>>| (greater than, greater, greater than), in the whole file. This lets us check that there are no unresolved conflicts left. Nice, now that we fixed the conflict, you can finish the merge.Do you remember how to do it?
	
	We need to \verb|add| the \verb|all_checks.py| file, and then call \verb|git commit| to finish the merge. But first, we're going to save and close.
	
	The editor message shows that it's performing a merge of the remote branch with the local branch. We can add extra information to this message. For example, we can say that we fixed the conditional in the \verb|check_disk_usage| function to use the new variable name and the new order (Fig. \ref{W302e-merge}).
	
	\begin{figure} 
		\caption{Fixing code}
		\centering
		\includegraphics[scale=0.5]{W302e-merge.png}
		\label{W302e-merge}
	\end{figure}
	
	Our merge is finally ready, we can try pushing to the remote again. Yes, after fixing the conflict, we were able to push our work to the remote repo (Fig. \ref{W302e-push2}). 
	
	\begin{figure} 
		\caption{git push fixed}
		\centering
		\includegraphics[scale=0.5]{W302e-push2.png}
		\label{W302e-push2}
	\end{figure}
	
	Let's look at the commit history of the master branch now, by calling:
	
	\verb|git log --graph --oneline| (Fig. \ref{W302e-log3}).
	
	\begin{figure} 
		\caption{git push fixed}
		\centering
		\includegraphics[scale=0.5]{W302e-log3.png}
		\label{W302e-log3}
	\end{figure}
	
	We see that the latest commit is the merge, followed by the two commits that caused the merge conflict, which are on split paths in our graph. As we called out before, when Git needs to do a \verb|three-way merge|, \textbf{we end up with a separate commit for merging the branches back into the main tree}. Now we know how to successfully complete a pull, merge, and push cycle, even when it means doing some manual merges. 
	
	This was a complex exercise, and it's okay if some things still seem a bit scary. We all felt panic the first time we encountered a merge conflict. But don't worry, it gets easier with practice. To practice dealing with merge conflicts, you want to have two copies of your repository in separate directories, then try editing the same lines of the same files. You can follow along with the examples shown here, or come up with your own.
	
	Up next, we'll talk about using branches with a remote repositories.

	\subsection{Pushing Remote Branches} \label{W303b}
	
	As we called up before, \textit{when using Git to work on a new feature or a big refactor of some kind, it's recommended best practice to create separate branches}. There are many advantages to doing this. For example, it might take you a while to finish a new feature and in the meantime, there could be a critical bug that needs fixing in the main branch of the code. By having separate branches, you can fix the bug in the main branch, release a new version and then go back to working on your feature without having to integrate your code before it's ready. Another advantage of working in separate branches is that \textit{you could even release two or more versions out of the same tree}. One being \textbf{the stable version} and the other being the \textbf{beta version}. That way, \textit{any disruptive changes can be tested on a few users or computers before they're fully released}. 
	
	So \textbf{let's start a new branch to work} on a small refactor of our code. Do you remember how to do that? You could create the branch first, and then check it out or \textit{we can just create it and check it out with} \verb|git checkout-b <branchName>| and the new branch name, in this case will br \verb|git checkout-b refactor|.
	
	\begin{figure} 
		\caption{git checkout -b refactor}
		\centering
		\includegraphics[scale=0.5]{W302f-checkout.png}
		\label{W302f-checkout}
	\end{figure}
	
	
	We're ready to start working on our refactor. Let's open up the file, and have a look at it.
	After some modifications and commits ...
	
\textbf{	Before we merge any of this into the }\verb|master branch|, we want to \verb|push| this into the \verb|remote| repo, \textbf{so that our collaborators can view the code, test it, and let us know if it's ready for merging}.
	
	The first time we push a branch to a remote repo, \textbf{we need to add a few more parameters} to the \verb|git push| command. 
	We'll need to add the \verb|-u| flag \textbf{to create the branch upstream}, which is another way of referring to remote repositories. We'll also have to say that \textbf{we want to push this to the origin repo}, and that we're pushing the \verb|refactor branch| with \verb|git push -u origin refactor|.
	
	\begin{figure} 
	 	\caption{git push -u origin refactor}
	 	\centering
	 	\includegraphics[scale=0.5]{W302f-push.png}
		\label{W302f-push}
	\end{figure}
	
	Whoa, that's a lot of information that Git's giving us. It's telling us if we want, we can create a pull request. We'll talk more about pull requests later on. For now, we're happy to see that new refactor branch has been created in the remote repo, which is what we wanted. This was a super complex example that incorporated a lot of concepts that we've learned about in this course, and also carried out some interesting Python concepts. If anything is still unclear, feel free to re-watch this video and follow along in your computer until you're comfortable with these steps. 
	
	So now that our branch is pushed to the remote repo, it can be reviewed by our collaborators. Assuming they say it's okay, \textbf{how should this branch get merged back into the master branch}? We'll talk about that in our next video.


	\subsection{Rebasing Your Changes} \label{W303c}

	In our last video, we mentioned that once our branch has been properly reviewed and tested, it can get merged back into the master branch. This can be done by us or by someone else. One option is to use the \verb|git merge| command that we discussed earlier. Another option is to use the \verb|git rebase| command. Rebasing means \textbf{changing the base commit that's used for our branch}. To understand what this means, let's quickly recap what we've learned about merges up till now. 
	
	As we've seen in a lot of our earlier examples, when we create a branch at a certain point in the repo's history, \textbf{Git knows the latest commit that was submitted on both branches}. 
	
	\begin{figure} 
		\caption{Master and feature branches}
		\centering
		\includegraphics[scale=0.5]{W302g-flow.png}
		\label{W302g-flow}
	\end{figure}
	
	If \textit{only one of the branches has new changes when we try to merge them, Git will be able to fast forward and apply the changes}. But if both branches have new changes when we try to merge, \textbf{Git will create a new merge commit} for the \verb|three way merge|.
	
	\begin{figure} 
		\caption{Master and feature branches with commits}
		\centering
		\includegraphics[scale=0.5]{W302g-flow2.png}
		\label{W302g-flow2}
	\end{figure}
	
	The problem with \verb|three way merges|\textbf{ is that because of the split history, it's hard for us to debug when an issue is found in our code, and we need to understand where the problem was introduced}. By \textbf{changing the base where our commits split from the branch history, we can replay the new commits on top of the new base}. This \textbf{allows Git to do a fast forward merge and keep history linear}.
	
	\begin{figure} 
		\caption{git rebase}
		\centering
		\includegraphics[scale=0.5]{W302g-flow3.png}
		\label{W302g-flow3}
	\end{figure}
	
	
	So how do we do it? We run the command \verb|git rebase|, followed by the \textbf{branch that we want to set as the new base}. When we do this, Git will \textit{try to replay our commits after the latest commit in that branch}. This will work automatically if the changes are made in different parts of the files, but \textbf{will require manual intervention} if the changes were made in other files.
	Let's check out this process by \textbf{rebasing our refactor branch onto the master branch}. 
	
	First, we'll \verb|check out| the master branch and \verb|pull| the latest changes in the remote repo.
	
	\begin{figure} 
		\caption{git rebase}
		\centering
		\includegraphics[scale=0.5]{W302g-pull.png}
		\label{W302g-pull}
	\end{figure}
	
	
	Git tells us that \textit{it's updated the master branch with some changes that our colleague had made}. At this point, \textit{the changes that we have in the} \verb|refactor branch| \textit{can no longer be merged through fast forwarding into the} \verb|master branch|. That's \textbf{because there's now an extra commit in the master that's not present in the refactor}.
	
	Let's see how this looks by asking the \verb|git log --graph --oneline --all| command to show us the current graph of all branches (Fig. \ref{W302g-log}).
	
	\begin{figure} 
		\caption{git log --graph --oneline --all}
		\centering
		\includegraphics[scale=0.5]{W302g-log.png}
		\label{W302g-log}
	\end{figure}
	
	It might take a bit to follow everything that's going on with this graph. But it can be really useful to understand complex history trees. As you can see, \textbf{the refactor branch has three commits before the common ancestor} (\verb|commit 58351ff|), with the current commit that's at the head of the master branch (\verb|commit 0789f64|). 
	
	If we merged our branch now, it would cause a \verb|three way merge|. But we want to \textbf{keep our history linear}. We'll do this \textbf{with a rebase of the refactor against master} (Fig. \ref{W302g-checkout}).
	
	\begin{figure} 
		\caption{git checkout and then git rebase}
		\centering
		\includegraphics[scale=0.5]{W302g-checkout.png}
		\label{W302g-checkout}
	\end{figure}
	
	The line \verb|git rebase nameOfBranch| moves the current branch on top of the \verb|nameOfBranch| branch.
	As usual, Git gives us a bunch of helpful information. It says that it rewound head and replayed our work on top of it. And luckily, everything succeeded. Let's look at the output of \verb|git log --graph --oneline| for our branch right now (Fig. \ref{W302g-log2}).
	
	\begin{figure} 
		\caption{git checkout and then git rebase}
		\centering
		\includegraphics[scale=0.5]{W302g-log2.png}
		\label{W302g-log2}
	\end{figure}
	
	The previous \verb|HEAD -> master commit 0789f64| was converted into a \textit{base} for the commits in \verb|refactor branch| (\verb|commits e914aee, 75bdd43| and |\verb|cbee3f7|), these commits were applied to tha \textit{base} becoming the \verb|commits| \verb|5d2e3eb,18257a0| and \verb|f5813b1|.
	Now we can \textbf{see the master branch and linear history with our list of commits}. We're ready to merge our commits back onto the main trunk of our repo and have this fast forwarded. To do that, we'll check out the master branch (\verb|git checkout master|) and merge the refactor branch (\verb|git merge refactor|).
	
	Awesome,\textbf{ we were able to merge our branch through a fast forward merge and keep our history linear}. We're now done with our refactor and can \textbf{get rid of that branch, both remotely and locally}. To \textbf{remove the remote branch}, we'll call \verb|git push --delete origin refactor|. To \textbf{remove the local branch}, we'll call \verb|git branch -d refactor|.
	
	Yes, we're done with our refactor. We can now push changes back into the remote repo (\verb|git push|).
	
	All right, we've just gone through an example using the git rebase command. We had a feature branch created against an older commit from master. So we rebased our feature branch against the latest commit from master and then merged the feature branch back into master.
	
	That was a complicated exercise. So if you're still confused about what's going on, take your time to review, and maybe come up with your own examples when you'd use a rebase.
	
	Up next, we'll look at another example of how to use rebase.

	\subsection{Another Rebasing Example} \label{W303d}

	In our last video, we looked at an example use case for git rebase. Where we used it to rebase a feature branch so that it could be cleanly integrated. There are many other possible uses of rebase. One common example is to rebase the changes in the master branch when someone else also made changes and we want to keep history linear. This is a pretty common occurrence when you're working on a change that's small enough not to need a separate branch and your collaborators just happened to commit something at the same time. Let's check out how this would work in practice. First, we'll make a change to our script.
	
	Now that we've made it easy to add new checks, will add a check to warn when there's no working network. There's a ton of things to check for this but for now we'll keep it simple and just check whether we can resolve the google.com URL. To do this, we'll use the socket module. We'll add a new function called check no network that will return true if it fails to resolve the URL and false if it succeeds. This socket.gethostbyname function raises an exception on failure. So we'll use it try except block to wrap the call to the function and return false when the call succeeds or true when it fails.
	
	With this new function defined, we can now add the check to our list of checks. We'll just add the name of the function and the message will be, "No working network."
	
	We've made the change, let's save it and commit it.
	
	Once more we'll use the git commit -a shortcut and pass a message saying that we've added a simple network connectivity check.
	
	We want to check if one of our teammates also made a change in the master branch while we were working on our change. In an earlier video, we showed how to do that by running git pull which will automatically create a three-way merge if necessary. In this example, we want to look at a different approach to keep our project history linear. So we'll start by calling git fetch which you might remember we'll put the latest changes into the origin slash master branch but we won't apply them to our local master branch.
	
	We see that we fetched some new changes. This means that if we tried to merge our changes, we end up with a three-way merge. Instead, we'll now run git rebase against our origin/master to rebase our changes against those made by our colleague and keep history linear.
	
	We've got a conflict and we'll need to fix it. Git is giving us a lot of info on what it tried to do including what worked, what didn't work and what we can do about it. Since we asked it to rebase, it tried to rewind our changes and apply them on top of what was in the \verb|origin/master branch|. The first commit made by our colleague, renamed \verb|all_checks.py| to \verb|health_checks.py|. Git detected this and automatically merged our changes into the new file name. But when trying to merge our changes with the changes made by our colleague in the file, there was a merge conflict. The output gives us a bunch of instructions on how to solve this. We could fix the conflict, skip the conflicting commit or even abort the rebased completely. In this example, we want to fix the conflict. So let's do that. We'll start by looking at the current state of the \verb|health_checks.py| file.
	
	We see that while we were adding the connectivity check, our colleague was adding a check for the CPU being constrained. We want both functions and the end result. So let's remove the conflict markers, cleaning up our file.
	
	This looks good. Let's save and test our script out.
	
	So close it looks like our colleague forgot to import the psutil module. Let's do that now.
	
	Let's hope this works.
	
	We fix the conflict and our script is working again. We now need to add the changes made to the \verb|health_checks.py| file and continue with the rebase.
	
	Now, the rebase has finished successfully let's check out the output of
	
	\verb|git log --graph --oneline| to see what the history looks like at this point. We see that we've applied our change on top of the other changes without needing a \verb|three-way merge|. What we did just now to resolve the conflict is very similar to what we did earlier to merge our changes. The difference is, that the commit history ended up being linear instead of branching out. We're now ready to push our new check to the remote repo.
	
	In this example, we've seen how we can use the fetch rebase push workflow to merge our changes with our collaborators changes while keeping the history of our changes linear. 
	As we called out, keeping history linear helps with debugging especially when we're trying to identify which commit first introduced a problem in our project. 
	We've now seen two examples of how to use the git rebase command. 
	One for merging feature branches back into the main trunk of our code and one for making sure that our commits made in the master branch apply cleanly on top of the current state of the master branch and it doesn't stop there. We can also use git rebase to change the order of the commits or even squash two commits into one. 
	This is a very powerful tool but don't worry you don't need to memorize all of its possible uses you'll learn them as you need them. 
	Up next, we'll do a round up of some of the best practices for operating with git when collaborating with others.

	\subsection{Best Practices for Collaboration} \label{W303e}

	Over the past few videos, we've looked at a lot of things we can do with Git and remote repositories. It's worth spending some time talking about best practices for collaborating with others. It's a good idea to \textbf{always synchronize your branches before starting any work on your own}.
	
	That way, whenever you start changing code, you know that you're starting from the most recent version and you minimize the chances of conflicts or the need for rebasing. Another common practice is to try and \textbf{avoid having very large changes that modify a lot of different things}. Instead, try to make changes as small as possible as long as they're self-contained. For example, if you are renaming a variable for clarity reasons, you don't want to have code that adds new functionality in the same commit. It's better if you split it into different commit. This \textbf{makes it easier to understand what's going on with each commit}.
	
	On top of that, \textbf{if you remember to push your changes often and pull before doing any work, you reduce the chances of getting conflict}. We called out already that \textbf{when working on a big change, it makes sense to have a separate feature branch}.
	
	This lets you work on new changes while still enabling you to fix bugs in the other branch. To make the final merge of the feature branch easier, it makes sense to \textbf{regularly merge changes made on the master branch back onto the feature branch}.
	
	This way, we won't end up with a huge number of merge conflicts when the final merge time comes around.
	
	If you need to maintain more than one version of a project at the same time, it's common practice to \textbf{have the latest version of the project in the master branch and a stable version of the project on a separate branch}.
	
	You'll merge your changes into the separate branch whenever you declare a stable release.
	
	When using these two branches, some bug fixes for the stable version may be done directly on the stable branch if they aren't relevant to the latest version anymore. In the last couple of videos, we looked at how we can use \texttt{rebase} to make sure our history is linear. Rebasing can help a lot with identifying bugs, but use it with caution. \texttt{Whenever we do a rebase, we're rewriting the history of our branch}. The old commits get replaced with new commits, so they'll be based on different snapshots than the ones we had before and they'll have completely different hash sums. This works fine for local changes, but can cause a lot of trouble for changes that have been published and downloaded by other collaborators. So as a general rule, \textbf{you shouldn't rebase changes that have been pushed to remote repos}.
	
	The Git server will automatically reject pushes that attempt to rewrite the history of the branch. It's possible to force Git to accept the change, but it's not a great idea unless you really know what the implications will be. In our \texttt{feature} branch example, we rebased the branch. Merged it to the master and then deleted the old one. That way, we didn't push the rebase changes to the refactor branch, only to the master branch that hadn't seen those changes before.
	
	Early in our Git journey, we mentioned that \textbf{having good commit messages is important}. It's already important when you're working alone since good commit messages help the future you understand what's going on, but it's even more important when you're collaborating with others since it gives your collaborators more context on why you made the change and can help them understand how to solve conflicts when necessary. So commit to being a good collaborator and remember to add those commit messages.
	
	Whenever we collaborate with others, there's bound to be some merge conflicts and they can sure be a pain.
	
	I've definitely been frustrated when encountering complex merge conflicts and trying to debug the results. If I'm dealing with this type of merge conflict, my first step is to work backward and disable everything I've done and then see if the source still works, then I slowly add pieces of code until I hit the problem. That usually gets me through the tough times and has definitely highlighted some weird occurrences. Up next, we have a reading that puts together all the commands related to solving conflicts and then a quick practice quiz.

	\subsection{Reading: Conflict Resolution Cheat Sheet} \label{W303f}

	Merge conflicts are not uncommon when working in a team of developers, or on Open Source Software. Fortunately, GitHub has some good documentation on how to handle them when they happen:
	
	\begin{itemize}
		\item \url{https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-merge-conflicts}
		\item \url{https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/resolving-a-merge-conflict-using-the-command-line}
	\end{itemize}
	
	You can also use git rebase branch name to change the base of the current branch to be branchname
	
	The git rebase command is a lot more powerful.  Check out this link for more information.

