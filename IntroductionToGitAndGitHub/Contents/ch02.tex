%%%%%%%%%%%%%%%%%%%%% chapter.tex %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% sample chapter
%
% Use this file as a template for your own input.
%
%%%%%%%%%%%%%%%%%%%%%%%% Springer-Verlag %%%%%%%%%%%%%%%%%%%%%%%%%%
%\motto{Use the template \emph{chapter.tex} to style the various elements of your chapter content.}
\chapter{Week 2}

\section{Advanced Git Interaction}

	\subsection{Intro to Module 2: Using Git Locally}
	
	Welcome back. Up till now, we've talked about what version control is, why it's necessary, and how we might benefit from it in diverse context. We also started learning some basic Git commands, and procedures, nice job. Over the course of the next videos, we'll go into much more detail about what we can do with Git. 
	These are Git's greatest hits. 
	
	We'll start by learning some handy shortcuts and looking into how we can get more info out  of our version control system. Then we'll experience the true power of Git by seeing how we can undo some of our changes. The ability to revert previous changes is one of the most useful aspects of version control systems. Depending on what needs to be undone, there's a bunch of different techniques that we can use in Git. We can discard the changes made to a file, fix a commit that was incorrect and even roll back our project to an older snapshot. We'll look into all these techniques and dive into when to use each of them. 
	
	Finally, we'll check out yet another important concept, Branches. We can use branches to work on an experimental feature without affecting the main code of our project. Support separate versions of a program that can't be merged together and much more. We'll dive into \textbf{what branches are, when and how to use them and how to deal with merge conflicts}. 
	
	Admittedly, some of these concepts can get pretty tricky, so we really recommend that you follow along in your computer, experiment with the commands that we show, and try things on your own so you feel comfortable with these techniques. Remember that you can always go back and review any earlier videos if something isn't totally clear. If after all this you still feel stuck, be sure to use the discussion forums to ask for help as well. So you're ready to learn more about advanced features in Git, let's get to it.
	
	\subsection{Skipping the Staging Area}
	
	When we covered the basic Git workflow, we called out that the process is usually to make changes, stage them, and then commit them. The separate step between staging and committing allows us to stage several changes in one commit. But if we already know that the current changes are the ones that we want to commit, we can skip the staging step and go directly to the commit. No dress rehearsals. We do this by using the dash a-flag to the git commit command (\verb|git commit -a|). This flag automatically stages every file that's tracked and modified before doing the commit letting it skip the \texttt{git add} step. 
	
	At first, you might think that \verb|git commit -a| is just a shortcut for \texttt{git add} followed by \texttt{git commit} but \textbf{that's not exactly true}. Actually \verb|git commit -a| \textbf{doesn't work on new files because those are untracked}. Instead, \verb|git commit -a| is a shortcut to stage any changes to tracked files and commit them in one step. \textbf{If the modified file has never been committed to the repo, we'll still need to use git add to track it first}. 

	So let's make a change to our example script from an earlier video and try out this new flag. We'll now modify our main function and make it call the check reboot function that we wrote before. If a reboot is pending, we'll print a message and then exit our program with an exit status of one. Since we're using the sys module, we'll need to import it (Fig. \ref{W201a}).

\begin{figure} 
	\caption{Using \texttt{Function modified.}}
	\centering
	\includegraphics[scale=0.2]{W2/W201a.png}
	\label{W201a}
\end{figure}
	
	
	All right. Now that we've made the change, we're ready to try out the new \verb|-a| flag. We'll also use the \verb|-m| flag to add the commit message directly. This time, we'll say that we're calling check underscore reboot and exiting with one on the error condition (\texttt{git commit} \verb|-a -m|   Call \verb|check_reboot| from main, exit with 1 on error). 
	Success. These shortcuts are useful when making small changes that we know we'll want to commit directly without keeping them in the staging area and having to write long and complex descriptions. 
	
	Keep in mind that \textbf{when you use the} \verb|-m| \textbf{shortcut, you can only write short messages} and can't use the best practices regarding commit descriptions that we talked about earlier. \textbf{So it's best reserved for truly small changes} that don't require extra context or explanation, short and sweet. 
	
	Heads up, when you use the \verb|-a| shortcut, you skip the staging area. Meaning, you can't add any other changes before creating the commit. So you need to be sure that you've already included everything you want to include in that commit. In the end, using a shortcut like -a is just like using the regular commit workflow. The commit will show up in the \texttt{log} along with the message just as usual. Let's check that out. 
	
	\begin{figure} 
		\caption{Using \texttt{git log.}}
		\centering
		\includegraphics[scale=0.2]{W2/W201a.png}
		\label{W201b}
	\end{figure}
	
	See how our latest commit was added to the top of the list of commits and notice how the \texttt{Head} indicator has now moved to the latest commit (red line). You might be wondering, what is this \texttt{Head} and where is it heading? We'll keep coming across it. So let's clarify. 
	
	Git uses \textbf{the head alias to represent the currently checked out snapshot of your project}. This lets you know what the contents of your working directory should be. 
	\textbf{In this case, the current snapshot is the latest commit in the project}. We'll soon learn about branches. In that case, (if we consider branches ) \textbf{head can be a commit in a different branch of the project}.
	We can even use git to go back in time and have head representing old commit from before the latest changes were applied.
	In all cases, head is used to indicate what the currently checked out snapshot is. This is how git marks your place in the project. \textbf{Think about it as a bookmark that you can use to keep track of where you are}. Even if you have multiple books to read, the bookmark allows you to pick up right where you left off. 

	When you run git commands like diff, branch, or status, git will use the head bookmark as a basis for whatever operation it's performing. We'll see \texttt{Head} used when we learn how to undo things and perform rollbacks. We'll talk more about branches in later videos. As a shortcut, \textbf{it's generally easy to think of head as a pointer to the current branch}, although it can be more powerful than that. Next, we'll dig into how we can get more information about our changes, both before and after we commit them.
	
	\subsection{Getting More Information About Our Changes}
	
	We've seen how git log shows us the list of commits made in the current Git repository. By default, it prints the commit message, the author, and the date of the change. This is useful, but if we're combing through a history of changes in a repo to try and find what caused the latest outage, we'll probably also need to look at the actual lines that changed in each commit. To do this with \texttt{git log}, we can use the \verb|-p| flag. The \texttt{p} comes from \texttt{patch}, because using this flag gives us the patch that was created. Let's try it out (Fig. \ref{W202a}).
	
	\begin{figure} 
		\caption{Using \texttt{git log} -p}
		\centering
		\includegraphics[scale=0.2]{W2/W202a.png}
		\label{W202a}
	\end{figure}
		
	The format is equivalent to the \verb|diff-u| output that we saw on an earlier video.
	
	It shows added lines (green color) with plusses and remove lines (red color) with dashes. Because the amount of text is now longer than what fits on your screen, Git automatically uses a paging tool that allows us to scroll using page up, page down, and the arrow keys.
		
	We still have one commit below the other, but now each commit takes up a different amount of space, depending on how many lines were added or removed in that commit.
	
	Using this option, we can quickly see what changes were made to the files in our repository. This can be especially useful if we're trying to track down a change that recently broke our tools. If we don't want to scroll down until we find the commit that we're actually interested in, another option is to use the \texttt{git show} command. This command takes a \texttt{commit ID} \textbf{as a parameter}, and will display the information about the commit and the associated patch. We'll talk more about \texttt{commit IDs} in a later video. But for now, remember that this is an identifier that we see next to the word commit in the log.
	
	Let's check this out by first listing the current commits in the repo and then calling \texttt{git show} (Fig. \ref{W202c}) for the second commit in the list. First, I'm going to exit out by pressing \texttt{q}.

\begin{figure} 
	\caption{Using \texttt{git log} }
	\centering
	\includegraphics[scale=0.2]{W2/W202b.png}
	\label{W202b}
\end{figure}

\begin{figure} 
	\caption{Using \texttt{git show} }
	\centering
	\includegraphics[scale=0.2]{W2/W202c.png}
	\label{W202c}
\end{figure}
	
	We've shown how we can use \texttt{git log} for listing commits , and \verb|git log -p| for showing the associated patches. Another interesting flag for \texttt{git log} is the \verb|--stat| flag. This will cause \texttt{git log} to \textbf{show some stats about the changes in the commit}, like which files were changed and how many lines were added or removed. Let's try it with our repo (\verb|git log --stat|).

	There are a bunch of other options to git log, so we won't cover them all. You can always use the reference documentation or the manual pages to find out more. And as we called up before, you don't need to memorize any of this, you'll learn the different commands and flags by using them.
	
	The important thing to remember is that all the information is stored in the repository and you have it at your fingertips when you need it. You're welcome.
	
	Now, what about changes that haven't been committed yet? Until now, whenever we've made changes to our files, we've either added them to the staging area with \texttt{git add} and committed them with \texttt{git commit}, or committed them directly using \texttt{git commit} \verb|-a|. This works fine, but it means we have to know exactly which changes we've made. Sometimes it can take a while until we're ready to commit. We call these commitment issues. Just kidding. But imagine you've been working on adding a new complex feature to a script and it requires thorough testing.
	
	Before committing it, you need to make sure that it works correctly. Check that all the test cases are covered and so on and so on. So while doing this you find bugs in your code that you need to fix. It's only natural that by the time you get to the commit step you don't really remember everything you changed. To help us keep track git gives us the \textbf{git diff} command.
	
	Let's make a new change to our script and then try this command out. We'll add another message to the user to say that everything is okay when the check is successful and then exit with 0 instead of 1.
	
	Okay, we've made the change. Let's now save it and check out what \textbf{git diff} shows us (Fig. \ref{W202d}).
	
	\begin{figure} 
		\caption{Using \texttt{git diff} }
		\centering
		\includegraphics[scale=0.2]{W2/W202d.png}
		\label{W202d}
	\end{figure}
	
	Again, this format is equivalent to the \verb|diff -u| output that we saw in an earlier video.
	
	In this case, we see that the only change is the extra lines that we've added (green color). If our change was bigger and included several files, we could pass a file by parameter to see the differences relevant to that specific file instead of all the files at the same time. Something else we can do to review changes before adding them is to use the \verb|-p| flag with the git add command.
	
	When we use this flag, \textbf{git will show us the change being added and ask us if we want to stage it or not} (we will get \texttt{Stage this hunk} \verb|[y,n,q,a,d,e,?]?|).
	
	This way we can detect if there's any changes that we don't want to commit. Let's try that one out.
	
	We've staged our change and it's \textbf{now ready to be committed}.
	
	If we call \texttt{git diff} again, \textbf{it won't show any differences, since git diff shows only unstaged changes by default}. Instead, we can call \texttt{git diff} \verb|--staged| to see the \textbf{changes that are staged but not committed}. With this command, we can see the actual stage changes before we call git commit.
	
	Let's commit these changes now so that they aren't pending anymore.	We'll say that we've added a message when everything's okay ( \texttt{git commit} \verb|-m| 'Add a message when everything is ok').
	
	Nice, and with that, we've learned a bunch of different ways to get more information about our changes. We've covered a lot of ground, so take the time to review and practice these commands if they don't make sense yet. Up next, we'll look into what happens when we want to delete or rename files in our repository. It's time to do a little housekeeping.
	
	\subsection{Deleting and Renaming Files}
		
	Let's say that you've decided to clean up some old scripts and want to remove them from your repository.
	
	Or you've done some refactoring, which makes that particular file, obsolete. You can remove files from your repository with the \texttt{git rm} command, which will stop the file from being tracked by git and remove it from the git directory.
	
	File removals go through the same general workflow that we've seen. So you'll need to \textbf{write a commit message as to why you've deleted them}. Let's try this out in our checks repository that contains a file we decided we actually don't want. 
	
	Well first look the contents of the directory with \texttt{ls}, then delete the file with \texttt{git rm}, then check the contents with \texttt{ls} again, and finally check the status with \texttt{git status} (First \verb|ls -l|, then \verb|git rm process.py| , \verb|ls -l| and finally \verb|git status|).
	
	So, we see that by calling \texttt{git rm}, \textbf{the file was deleted from the directory, and the change was also staged to be committed in our next commit}. Let's do that now, by calling \texttt{git commit} and sending a message indicating that we've deleted the unneeded file (\texttt{git commit} \verb|-m 'Delete unneeded processes file'|).
	
	As usual, we get a bunch of stats when we do the commit . Check out all the deletions that reported.
		
	These are all lines in the file that are no longer there (\texttt{1 file changed, 23 deletions} \verb|(-)|). And it states the file itself was deleted. 
	
	What if you have a file that isn't accurately named? This can happen. For example, if you start writing a script that you thought would only do one thing, and then expands to cover more use cases. Or conversely, if you named your script thinking that it would be very generic, but it ends up being more specific. You can use the \texttt{git mv} command to \textbf{rename files} in the repository. Let's rename our existing script to \verb|check_free_space.py| and check what \texttt{git status} has to say about that (\texttt{git mv} \verb|disk_usage.py| \verb|check_free_space.py| and then \texttt{git status}).
	
	The status shows us that \textbf{the file was renamed} (in green color \texttt{renamed: } \verb|disk_usage.py ->| \verb|check_free_space.py|) and clearly displays the old and new names. As with the previous example, \textbf{the change is staged, but not committed}. Let's commit it by calling \texttt{git commit} once again (\texttt{git commit} \verb|-m| \verb|'New name for disk_usage.py'|).
	
	The \texttt{git mv} command works in a similar way to the \texttt{mv} command on Linux and so can be used for both moving and renaming. If our repository included more directories in it, we can use the same git mv command to move files between directories.
	
	As you can probably tell from our examples, the output of \texttt{git status} is a super useful tool to help us know what's up with our files. It shows us which files have tracked or untracked changes, and \textbf{which files were added, modified, deleted or renamed}. It's important that the output of these commands stays relevant to what we're doing. If we have a long list of untracked files, we might lose an important change in the noise. If there are files that get automatically generated by our scripts, or our operating system generates artifacts that we don't want in our repo, we'll want to ignore them so that they don't add noise to the output of git status. To do this, we can use the \texttt{git ignore} file.
	
	Inside this file, we'll specify rules to tell git which files to skip for the current repo.
	
	For example, if we're working on an OSX computer, we'll probably want to ignore the dot DS store file, which is automatically generated by the operating system. To do this, we'll create a \verb|.gitignore| file containing the name of this file (\texttt{echo} \verb|.DS_STORE > .gitignore|).
	
	Remember that the \textbf{dot prefix in a Unix-like file system indicates that the file or directory is hidden} and won't show up when you do the normal directory listing. That's why we have to use \verb|ls-la| to see all files.
	
	We've added a git ignore file to our repo but we haven't committed it yet. This file needs to get tracked just like the rest of the files in the repo. Let's add it now (\verb|git add .gitignore|).
	
	Looks great. We've learned a lot of new commands and techniques related to git in these past videos. If anything isn't clear at this point, now's a good time to experiment on your own and share any challenges in the discussion forums. Coming up, we put together a cheat sheet listing all the new commands and options. After that, a quiz let you practice these concepts. Now, go on, get.
	
	\subsection{Reading: Advanced Git Cheat Sheet}
	
	\begin{itemize}
		\item \verb|git commit -a| : Stages files automatically.
		
		\item \verb|git log -p| : Produces a patch text.
		
		\item \verb|git show| : Show various objects.
		
 		\item \verb|git diff| : (Similar to Linux \texttt{diff} command) Show the differences in various commits.
 		
		\item \verb|git diff --staged| : An alias to \verb|--cached|, this will show all staged files compared to the named commit.
 		
 		\item \verb|git add -p| : Allows a user to interactively review patches to add to the current commit.
 		
 		\item \verb|git mv| : (Similar to Linux \texttt{mv} command) moves a file.
 		
 		\item \verb|git rm| : (Similar to Linux \texttt{rm} command) deletes or removes a file.
		 
		 
	\end{itemize}

\section{Undoing Things}

	\subsection{Undoing Changes Before Committing}
	
	Being able to revert our changes is one of the most powerful features offered by version control systems. There's a bunch of different techniques available depending on which changes we need to undo. In this video and the next few coming up, we'll talk about the most common ways to revert changes in Git and when to use each approach. For example, you might find yourself in a situation where you've made a bunch of changes to a file but decide that you don't want to keep them. You can change a file back to its earlier committed state by using the \texttt{git checkout} command followed by the name of the file you want to revert (\texttt{git checkout filename}). Speaking of, let's try this out using our scripts repository. We'll edit our \verb|all_checks.py| script and remove the \verb|check_reboot| function, then save and go back to the command line.
	
	Cool. We've made our change. Let's try our script and see what happens.
	
	By deleting that function, we've actually broke the script (it does not run). Let's see what git status has to say about this. As expected, we see that \textbf{our file is modified} and the \textbf{changes aren't staged yet}. Check out how git gives us a couple helpful tips on what to do now. We can run \texttt{git add} to \textbf{stage} our changes or we can run \texttt{git checkout} to \textbf{discard} them. 
	If you need help remembering what this command does, think of it this way, you're checking out the original file from the latest storage snapshot. Let's do that now. We'll check out at the original file and then take a look at what git status has to say about it and finally retry our script (\texttt{git checkout} \verb|all_checks.py|).
	 
	Looks like we have a typo. Let's go back and fix it.
	
	Done and done. With that, we've demonstrated how we can use \texttt{git checkout} \textbf{to revert changes to modify files before they get staged}. This command will restore the file to the latest storage snapshot, which can be either committed or staged. So \textbf{if you've made additional changes to a file after you've staged it, you can restore the file to the earlier stage version}. If you need to check out individual changes instead of the whole file, you can do that using the dash p (\verb|-p|) flag. This will ask you change by change if you want to go back to the previous snapshot or not. That's it for undoing unstaged changes. What if you added the changes to the staging area already? Don't stress. 
	
	If we realize we've added something to the staging area that we didn't actually want to commit, we can unstage our changes by using the \texttt{git reset} command. Staging changes that we don't actually intend to commit happens all the time. 
	Especially if we use a command like git add star (\verb|git add *|), where the star is a file glob pattern used in Bash that expands to all files. This command will end up adding any change done in the working tree to the staging area. 

	While sometimes that might be what we want, it can also lead to some surprises. Let's try it out with an example. First, we'll pretend we're trying to debug a problem in our script. For that, we create a temporary file with the output of our script (\verb|./all_checks.py > output.txt|). Then, we'll add all unstaged changes in our working tree using \verb|git add *|. 
	Finally, check the status using \texttt{git status}. 
	We can see that this output file, which was supposed to be a temporary file for debugging, has now been staged in our repo (\verb|output.txt|) but\textbf{ we didn't want to commit it}. Conveniently, the \textbf{git status} command tells us \textbf{how to unstage the file right there in the output}. The example output mentions the \texttt{head} alias. Remember what that means? That's right. It's the current checked out snapshot. So by running the suggested command, we're resetting our changes to whatever's in the current snapshot. Let's try it out (\texttt{git reset HEAD} \verb|output.txt|).
	
	The file \verb|output.txt| is once again untracked in our working tree and no longer staged. You can think of reset as the counterpart to add. With add, you can well add changes to the staging area. With reset, you remove changes from the staging area. You can use \texttt{git reset} \verb|-p| to get git to ask you which specific changes you want to reset. Get it?. But wait, let's remember to commit our typo fix.
	
	With that, we've seen how we can revert unstaged and stage changes. But \textbf{what if you've already created a commit with the changes that you want to undo?} Great question. That's coming up in the next video.
	
	\subsection{Amending Commits}
		
	In general, we try to make sure our commits include all the right changes and descriptions. But we're all human and we make mistakes. It's not uncommon for developers and IT specialists to realize that there is an error in a recent commit, which is why it's important to know how to take action and fix it. Let's say you just finished committing your latest batch of work, but \textbf{you've forgotten to add a file that belongs to the same change}. You'll \textbf{want to update the commit to include that change}. Or maybe the files were correct, but you realize that \textbf{your commit message just wasn't descriptive enough}. So you want to fix the description to add a link to the bug that you're solving with that commit. What can you do? We can solve problems like these using the \verb|--amend| option of the \texttt{git commit} command. When we run \texttt{git commit} \verb|--amend|, git will take whatever is currently in our staging area and run the \texttt{git commit} workflow to overwrite the previous commit. Let's see this in an example. We'll go to our scripts directory and create two new files using the \texttt{touch} command. Then list the contents of the directory using \verb|ls| at our Python script and commit it saying that we've added two files.
	
	\begin{itemize}
		\item \verb|cd scripts/|
		\item \verb|touch auto-update.py|
		\item \verb|touch gather-information.sh|
		\item \verb|ls -l|
		\item \verb|git add auto-update.py|
		\item \verb|git commit -m 'Add two new scripts'|
	\end{itemize}
	
	As you can see, the message printed by git says that only one file was added \texttt{1 file changed, 0 insertions(+), 0 deletions(-)}. Our \textbf{commit message said that we added two files, but we forgot to add one} of them. Ouch. Don't panic. We can fix it. We'll start by adding the missing file and then amending our commit.
	
	\begin{itemize}
		\item \verb|git add gather-information.sh|
		\item \verb|git commit --amend|
	\end{itemize}

	We call \verb|git commit --amend| and an editor opened up showing the commit message and the stats about the commit that we're working with. The list of added files for this commit now includes both files that we wanted to add. Yay. Now that the files have been added, we can also improve our initial commit message which was a bit too short. We'll keep the existing description as the first sentence of our commit, and then add a line of description about the intended purpose of each file.
	
	\begin{verbatim}
		Add two new scripts.
		
		gather-information.sh will be used to collect information in case of errors.
		auto-update.py will be run daily to update computers automatically.
	\end{verbatim}
	
	With that, our commit is ready to be amended. Let's save the new description as usual (\verb|ctrl+o|, then \verb|ENTER| and \verb|ctrl+x|).
	
	We've amended our previous commit to include both files and a better message. You could also just update the message of the previous commit by running the \verb|git commit --amend| command with no changes in the staging area. An important heads up. While \verb|git --amend| is okay for fixing up local commits, you \textbf{shouldn't use it on public commits}. Meaning, those that have been pushed to a public or shared repository. This is because using \verb|--amend| \textbf{rewrites the git history removing the previous commit and replacing it with the amended one}. This can lead to some confusing situations when working with other people and should definitely be avoided. So remember, fixing up a local commit with amend is great and you can push it to a shared repository after you fixed it. But\textbf{ you should avoid amending commits that have already been made public}. If this sounds confusing now, don't worry. We'll mention it again when we talk about collaborating with others through shared repositories. We've covered how to fix staged and unstaged changes, and how to fix a commit that was incomplete. Up next, we'll talk about what to do if you come across a bad commit that needs to be completely reverted.
	
	\subsection{Rollbacks}	
	
	Fixing your work before you commit is good. But what happens if it's already been snapshotted by Git? Let's say you host to Git repository on a company server that contains all kinds of useful automation scripts that you and your coworkers use. One morning before coffee, you make a few changes to one of these scripts and commit the updated files. A few hours later, you start to receive tickets from users indicating some part of the script is broken. From the errors they describe, it sounds like the problem is related to your recent changes. Oh, you could look at the code you updated to see if you can spot the bug. But more tickets are pouring in and you want to fix the problem as fast as possible. You decided it's time for a rollback. There are a few ways to rollback commits in Git. For now, we'll focus on using the \texttt{git revert} command. Git revert doesn't just mean undo. Instead, \textbf{it creates a commit that contains the inverse of all the changes made in the bad commit in order to cancel them out}.
	
	For example, if a particular line was added in the bad commit, then in the reverted commit, the same line will be deleted. This way \textbf{you get the effect of having undone the changes, but the history of the commits in the project remains consistent leaving a record of exactly what happened}. So \texttt{git revert} \textbf{will create a new commit}, that is the opposite of everything in the given commit. We can revert the latest commit by using the \texttt{Head} alias that we mentioned before. Since we can think of \texttt{Head} as a pointer to the snapshot of your current commit, when we pass \texttt{Head} to the \texttt{revert} command we tell Git to rewind that current commit, makes sense? To check this out, we'll first add a faulty commit to our example repo.

	\begin{verbatim}
		cd scripts
		atom all_checks.py  #Something was edited
		git commit -a -m 'Add call to disk_full function'		
	\end{verbatim}
	We've added some code to our script. Let's save and commit this.
	So now, our code is committed. We didn't even test it which is a bad idea if you're doing this for real. You might have already spotted the problem with our code. This is where users start filing tickets and saying that things are broken, and so we run our script to see what happens.
	
	Oops, we use the function that we forgot to define. Okay. It's rollback time. Let's get rid of this faulty code by typing \texttt{git revert head}. 
	So once we issue that git revert command, we're presented with the text editor commit interface that we've all seen before. 
	
	\begin{verbatim}
		Revert "Add call to disk_full function"
		
		This reverts commit 5aab0fd....
	\end{verbatim}
	
	In this case, we can see that git has automatically added some text to the command indicating it's a rollback. The first-line mentions that it's reverting the commit we just did called \texttt{Add call to disk full function}. The extra description even includes the identifier of the commit that got reverted. While we could use this description as is, it's usually a good idea to add an explanation of why we're doing the rollback. Remember that\textbf{ the goal of these descriptions is to help our future selves understand why things happen}. In this case, we'll explain that the reason for the rollback is that the code was calling a function that wasn't defined.
	
	\begin{verbatim}
		Revert "Add call to disk_full function"
		Readon for rollback: ...
		This reverts commit 5aab0fd....
	\end{verbatim}

	Once we're done entering the description, we can exit and save as usual. You'll notice the output that we get from the \texttt{git revert} command looks like the output of the \texttt{git commit} command. This is because \texttt{git revert}\textbf{ creates a commit for us}. Since a revert is a normal commit,\textbf{ we can see both the commit and the reverted commit in the log}. 
	
	Let's look at the last two entries in the log using dash P and dash two as parameters. As demonstrated before, the dash P parameter lets us see the patch created by the commit while the dash two perimeter limits the output to the last two entries. So in this log, we can see that when we called revert, git created a new commit that's the inverse of the previous one. This removes the lines that we added in the previous commit. We can see that the original commit shows the lines we added by preceding them with a plus sign. The same line shows up with a minus sign in the newer commit message indicating that they were removed. Just like that, the bad commit is reverted and the error stopped. In this example, we reverted the latest commit in our tree. But what if we had to revert a commit that was done before that? Rev up your time machines because in the next video, we're turning back the clock big-time.
	
	\subsection{Identifying a Commit}	
	
	So far we've used the head alias to specify the most recently checked out commit in our Git history. In our bad snapshot example, the error also happened to be in the most recently created commit, but errors can sometimes take a while to be detected. And so, we might need to revert other commits farther back in time. \textbf{We can target a specific commit by using its commit ID}. We've seen commit IDs a few times already. They show up when we're running the \texttt{git log} command, and we also saw the commit ID of the reverted commit in our last example.\textbf{ Commit IDs are those complicated looking strings} that appear after the word commit in the log messages. Let's have a look at the latest log entry in our checks repo.

	The commit ID is the 40 character long string after the word commit, you really can't miss it. This long jumble of letters and numbers is actually something called a \texttt{hash}, which is calculated using an algorithm called SHA1. Essentially, what this algorithm does is take a bunch of data as input and produce a 40 character string from the data as the output. In the case of Git, the input is all information related to the commit, and the 40 character string is the commit ID. Cryptographic algorithms like \texttt{SHA1} can be really complex, so we won't go too deep into what this means. If you're interested, you'll find links to more information in the next reading. Still you might be wondering, why on earth would you use a long jumble of letters as an ID for commit, instead of incrementing an integer, like 123, etc? To answer that, let's take a quick look at the reason why Git uses a hash instead of a counter, and how that hash is computed. Although SHA1 is a part of the class of cryptographic hash functions, Git doesn't really use these hashes for security. Instead, they're used to guarantee the consistency of our repository.
	
	Having consistent data means that we get exactly what we expect. To quote Git's creator, Linus Torvalds,\textit{ you can verify the data you get back out is the exact same data you put in}. This is really useful in distributed systems like Git because everyone has their own repository and is transmitting their own pieces of data. Computing the hash keeps data consistent because it's calculated from all the information that makes up a commit. The commit message, date, author, and the snapshot taken of the working tree. The chance of two different commits producing the same hash, commonly referred to as a \textbf{collision}, is extremely small. So small, it wouldn't happen by chance. It'd take a lot of processing power to cause this to happen on purpose. If you use a hash to guarantee consistency, you can't change anything in the Git commit without the SHA1 hash changing too.
	
	Remember our discussion about fixing commits with the dash dash amend (\verb|--amend|) command? Each time we amend a commit, the commit ID will change. This is why it's important not to use dash dash amend on commits that have been made public.
	
	The data integrity offered by the commit ID means that \textbf{if a bad disk or network link corrupt some data in your repository, or worse, if someone intentionally corrupt some data, Git can use the hash to spot that corruptio}n. Aha, it will say, the data you've got isn't the data you expected, something went wrong.
	
	Thank you, Detective Git, you've saved the day once again.
	
	Okay, enough backstory. How can you use commit IDs to specify a particular commit to work with, like during a rollback? Let's look at the last two entries in our repo using the \verb|git log -2| command.
	
	Say we realized that we actually liked the previous name of our script, and so we want to revert this commit where we renamed it. First, let's look at that specific commit using \texttt{git show}, which we mentioned in an earlier video (\texttt{git show 30e70712....} 40 characters).
	
	We've copied and pasted the commit ID that we wanted to display, and that works. Alternatively, we could provide just the first few characters identifying the commit to the command, and Git will be smart enough to guess which commit ID starts with those characters, as long as there's only one matching possibility. Let's try this out.
	
	Two characters is not enough, but usually four to eight characters will be plenty.
	
	Okay, now that we've seen how we can identify the commit that we want to revert, let's call the \texttt{git revert} (\texttt{git revert 30e70712}) command with this identifier. As usual, this will open an editor where we should \textbf{add a reason for the rollback}. In this case, we'll say that the previous name was actually better. Hooray for flip-flopping.
	
	As we called out before, when we generate the rollback,\textbf{ Git automatically includes the ID of the commit that we're reverting}. This is useful when looking at a repo with a complicated history that includes a lot of commits. Now, once w e save and exit the commit message, Git will actually perform the rollback and generate a new commit with its own ID. See how before the name of our commit the revert command already shows the first eight characters of the commit ID? Let's use git show to look at it.
	
	\begin{verbatim}
		$ git revert 30e70712
			[master 7d1de19] Revert "Title of the reverted commit"	
	\end{verbatim}

	All right, we've managed to revert a commit that wasn't the most recent one. Well done, time travelers. Over the past several videos we've covered a bunch of ways to undo things in Git. Whether for unstaged changes, staged changes, amending commits, or rolling back changes. If anything still seems unclear, now's a great time to practice these commands on your local computer, try things out, and come up with more examples of use cases you want to test. Up next, we've spun up a handy cheat sheet summarizing all the content we just covered. When you're ready, move on to the next quiz and put all this new knowledge into practice. We've been learning a lot of complex things over the past few videos, so once you're done with that quiz you should reward yourself for getting through this technical detail with a break. You earned it. Grab a coffee, tea, or snack and let the concepts settle for a bit. I'll meet you over the next video.
	
	\subsection{Reading: Git Revert Cheat Sheet}
	
	
	\texttt{git checkout} is effectively used to switch branches.
	
	\texttt{git reset} basically resets the repo, throwing away some changes. It’s somewhat difficult to understand, so reading the examples in the documentation may be a bit more useful. 
	
	There are some other useful articles online, which discuss more aggressive approaches to \texttt{resetting the repo}.
	
	\texttt{git commit --amend} is used to make changes to commits after-the-fact, which can be useful for making notes about a given commit .
	
	\texttt{git revert} makes a new commit which effectively rolls back a previous commit. It’s a bit like an undo command.
	
	There are a few ways you can rollback commits in Git. 
	
	There are some interesting considerations about how git object data is stored, such as the usage of sha-1. 
	
	Feel free to read more here:
	
	\begin{itemize}
		\item 	https://en.wikipedia.org/wiki/SHA-1
		\item  	https://github.blog/2017-03-20-sha-1-collision-detection-on-github-com/
	\end{itemize}
	
\section{Branching and Merging}

	\subsection{What is a branch}
	
	Up until now, we've only briefly mentioned branches. You might have seen the text on branch master and commit messages, or you might remember that we talked about branches in the context of the head pointer. Branches are an important part of the Git work flow. So we'll branch out and explore them more thoroughly in the coming videos. 
	
	So what is a branch? What is it used for? In Git, a branch at the most basic level is just \textbf{a pointer to a particular commit}. But more importantly, it r\textbf{epresents an independent line of development in a project}. Of which the commit it points to is the latest link in a chain of developing history. 
	
	The default branch that Git creates for you when a new repository initialized is called \texttt{master}. All of our examples and development have taken place on this branch so far. The\textbf{ master branch is commonly used to represent the known good state of a project}. 
	
	When\textbf{ you want to develop a feature or try something new in your project, you can create a separate branch} to do your work without worrying about messing up this current working state. 
	
	If this seems confusing, maybe an analogy will help. You can think of a Git project as an assignment your teacher gives you in a class. You do all your work on the assignment in a set of notebooks, each notebook representing a different branch. You use some notebooks to jot down rough drafts in experiments, but you keep one notebook the master branch, in a tidy state and you copy the polish versions of these drafts into it. No doodling in the master note book, please. \textbf{Branches make it really easy to experiment with new ideas or strategies and projects}. When you want to add a feature or fix something, you can create a new branch and do your development there. \textbf{You can merge back into the master branch, when you've got something you like, or discard your changes without negative impact if they don't work out.} 
	
	In Git, branches are used all the time, as a part of the normal development workflow. As an example, think back to the problematic commit we fixed in an earlier video. We added a call to the \verb|disk_full| function, but forgot to actually define the function. So we had to roll it back because our users we're seeing errors. Knowing what we know now, we could have done that work on a separate branch, maybe called something like 
	\verb|add_disk _full|. In that case, we could have iterated on our code there until it was working correctly, without it effecting the master branch. Only after the code is ready to be deployed, we would merge those changes back into the master branch. 
	
	In the next few videos, we'll look into how to create new branches and merge their content into the master branch. We'll also go over what to do if you run into any scary merge conflicts. Heads up, this is about to get pretty complicated. So make sure that you follow all of our exercises along in your computer and keep practicing coming up with new ways of using branches and merging, until you're comfortable with each of the steps we show.
	
	\subsection{Creating New Branches}
	
	As branches are essential to how work is done in git, there's tons of different ways to work with them. We can use the \texttt{git branch} command to \textbf{list, create, delete, and manipulate branches}. Running \texttt{git branch} by itself will show you a list of all the branches in your repository. Let's try it out in our checks repo.
	
	\begin{verbatim}
		$ cd checks
		$ git branch
		
	* master
	\end{verbatim}
	
	Our list is looking pretty empty right now, but don't worry. Creating a branch is a snap. We do it by calling \texttt{git branch} with the name of the new branch 
	Let's create a \verb|new-feature| branch and then list the branches again with git branch. 
	
	\begin{verbatim}
		$ git branch new-feature
		$ git branch
		
	* master
	  new-feature
	\end{verbatim}
	
	
	Our new branch was created based on the value of head. Remember that this might not necessarily be the master branch. The list we get shows that we're still on the master branch. We can tell because \textbf{the current branch is indicated in the command's output with an asterisk in a different color} (\verb|* master|). We'll look into other things that git branch lets us do with branches later on, but right now we want to switch to a new branch. To do that, we'll need to use the\texttt{ git checkout} command. We saw earlier how we can use git checkout to restore a modified file back to the latest commit. Checking out branches is similar in that, \textbf{the working tree is updated to match the selected branch including both the files and the git history}. If this seems a bit confusing at first, you're not alone. I also found it hard to wrap my head around it first. But rest assured that it will become clear after we use these commands for awhile. It might help to remember that \textbf{we use git checkout to check out the latest snapshot for both files and for branches}. All right. Let's switch to our new feature branch by calling git checkout new feature, and then listing our branches once again.
	
	\begin{verbatim}
		$ git branch new-feature
		$ git branch
		
		  master
		* new-feature
	\end{verbatim}
	
	Before we were working on the master branch but now that we've changed to our new branch, the star has moved to new feature. Creating a branch and switching to it immediately is a pretty common task. So common that git gives us a useful shortcut to create a new branch and to switch to it in a single command. We can use the \verb|git checkout -b new branch| to do this. Take a look.
	
	\begin{verbatim}
		$ git checkout -b even-better-feature
		Switched to a new branch 'even-better-feature'
	\end{verbatim}

	See how the message says that we've switched to a new branch? Git created the new branch and switched to it in just one command. Super efficient. Now that we have our shiny new branch, let's create a new file in. We'll create a new Python3 file, that will include the usual shebang line and empty main function and a call to that function.
	
	\begin{verbatim}
		$ atom free_memory.py
		(in GNU nano)
		#!/usr/bin/env python3
	
		def main():
			pass
	
		main()
	\end{verbatim}
	
	This file is empty because it's only the beginning of our work. As it's in a separate branch, it's okay for it to not be finished yet. Let's save our file and commit it to the current branch now.
	
	\begin{verbatim}
		$ git add free_memory.py
		$ git commit -m 'Add an empty free_memory.py'
	\end{verbatim}
	
	We've added a commit in this branch and it's looking better. Let's check the last two entries in the log.
	
	\begin{verbatim}
		$ git log -2
		commit 43618801... (HEAD -> even-beter-feature)
		Author: ...
		Date: ...
		
		commit 7d1de193... (new-feature, master)
		Author: ...
		Date: ...
		
	\end{verbatim}
	
	We see the last two commits in this branch. Notice how next to the latest commit ID, git shows that \textbf{this is where head is pointing to and that the branch is called} \verb|even-better-feature|. Next to the previous commit, git shows that both the master and the new feature branches are pointing to that snapshot of the project. In this way, we can see that the \verb|even-better-feature| branch is ahead of the master branch. With that, we've seen how we can create new branches and commit changes to them. You might say your knowledge of branches has grown. Up next, we'll learn even more things we can do to operate with branches. So stick around.
	
	\subsection{Working with Branches}	
	
	In our last video, we created a new branch different than the \texttt{master} branch and added a \texttt{commit} to it. Let's check out the current status of our repo by calling \texttt{git status} and \verb|ls -l|.
	
	\begin{verbatim}
		$ cd checks
		$ git status
		On branch even-better-feature
		nothing to commit, working tree clean
		
		$ ls -l
		total 8
		-rwxr-xr-x 1 user user 658 Jan  6 09:15 disk_usage.py
		-rw-r--r-- 1 user user  57 Jan  6 09:46 free_memory.py		
	\end{verbatim}	
	
	So we see that we're on a clean working tree in the \verb|even-better-feature| branch, and that a new \verb|free_memory.py| file is in our working tree. 
	Let's now change back to the \texttt{master} branch using \texttt{git checkout master} and then lists the latest two commits there. 
	
\begin{verbatim}
	$ git log -2
	commit 7d1de193... (HEAD -> master, new-feature)
	Author: ...
	Date: ...
	
	commit bb9bd782... 
	Author: ...
	Date: ...
		
\end{verbatim}	
	
	When we switch to a different branch using \texttt{git checkout}, under the hood, \textbf{git changes where head is pointing}. Thanks to this checkout,\textbf{ head went from pointing to the latest commit in the} \verb|even_better_feature| \textbf{branch to the most recent commit of the master branch}. 
	
	The commit from \verb|even_better_feature| doesn't show up at all, and the latest snapshot is the second entry we've seen before. Remember that\textbf{ when we switch branches, git will also change files in our working directory} or working tree to whatever snapshot head is currently pointing at. Let's look at the current contents of our directory.
	
	\begin{verbatim}
		$ ls -l
		total 4
		-rwxr-xr-x 1 user user 658 Jan  6 09:15 disk_usage.py		
	\end{verbatim}
	
	The file \verb|free_memory.py| isn't there. This demonstrates that\textbf{ when we switch branches in git, the working directory and commit history will be changed to reflect the snapshot of our project in that branch}. When we check out a new branch and commit on it, those changes will be added to the history of that branch. Since \verb|free_memory.py| was committed on another branch, it doesn't show up in the history or working directory of the master branch. 
	
	One thing to note after all this back and forth, is that \textbf{each branch is just a pointer to a specific commit in a series of snapshots}. It's very easy to create new branches because there isn't any data that needs to be copied around.\textbf{ When we switch to another branch, we check out a different commit and git updates both head and the contents of our working directory}. Head floats around with us. It's like a free spirit. What a head trip. Okay. We've now seen how to create and switch between branches. 
	
	So what if we \textbf{want to delete a branch that we don't need anymore}? We can do that by using git branch dash d (\texttt{git branch -d}).
	Let's first list the current branches in our repo and then get rid of the \verb|new-feature| branch by calling \verb|git branc -d new-feature|. Just like that, our branch was trimmed. We can check with another call to \texttt{git branch} that is not there anymore.
	
	\begin{verbatim}
		$ git branch
	  even-better-feature
	* master
	  new-feature
	  
	  	$ git branch -d new-feature
	  Deleted branch new-feature (was 7d1de19)
	  	
	  	$ git branch
      even-better-feature
  	* master
	\end{verbatim}
	
	If there are changes in the branch we want to delete that haven't been merged back into the master branch, git will let us know with an error.
	
	Hopefully, git also gives us the command to run if we were sure that we wanted to delete the branch, even if it has unmerged changes. But we won't do that just yet. We actually want to merge those changes back into the repo first. How do we do that? It's all coming up in our next video
	
	\subsection{Merging}
		
	
	A typical workflow for managing branches in Git, is to create a separate branch for developing any new features or changes. Once the new feature's in good shape, we merge the separate branch back into the main trunk of code. Merging is the term that Git uses for \textbf{combining branch data and history together}. We'll use the \texttt{git merge} command, which lets us \textbf{take the independent snapshots and history of one Git branch, and tangle them into another}.
	
	Let's try this out with our example branch from the last video. First, will \textbf{check that we're in master branch}, and then we'll call \texttt{git merge} \verb|even-better-feature| to merge the \verb|even-better-feature| branch into the master branch. 
	
	\begin{verbatim}
		$ git branch
		even-better-feature
		* master
		
		$ git merge even-better-feature
		Updating
		Fast-forward
			free_memory.py 
			1 file changed, 6 insertions(+)
			create mode 100644 free_memory.py
	\end{verbatim}

	Now we've brought the master branch up to speed, which we can see by looking at the git log.
	
	\begin{verbatim}
		$ git log
		
		commit 43618801... (HEAD -> master, even-better-feature)
		Author: ...
		Date: ...
		
		commit 7d1de193... 
		Author: ...
		Date: ...
		
		commit bb9bd782... 
		Author: ...
		Date: ...
		
	\end{verbatim}	
	
	As we're on the master branch, \texttt{HEAD} \textbf{points at} \texttt{master}. We can see the \verb|even-better-feature| and \verb|master| branches \textbf{are now both pointing at the same commit}.
	
	Git \textbf{uses two different algorithms to perform a merge}, \verb|fast-forward| and \verb|three-way| merge. The merge we just performed is an example of a \verb|fast-forward| merge. This kind of merge \textbf{occurs when all the commits in the checked out branch are also in the branch that's being merged} (Fig. \ref{W234a}).
		
	\begin{figure} 
		\caption{Using \texttt{Fast-forward merge.}}
		\centering
		\includegraphics[scale=0.2]{W2/W234a.png}
		\label{W234a}
	\end{figure}	
	
	If this is the case, we can say that \textbf{the commit history of both branches doesn't diverge}. In these cases, all \textbf{Git has to do is update the pointers of the branches to the same commit, and no actual merging needs to take place}. 
	
	On the other hand, a \verb|three-way| merge is performed when the history of the merging branches has diverged in some way, and \textbf{there isn't a nice linear path to combine} them via fast-forwarding. \textbf{This happens when a commit is made on one branch after the point when both branches split}.
	
	\begin{figure} 
		\caption{Using \texttt{Three-way merge.}}
		\centering
		\includegraphics[scale=0.2]{W2/W234b.png}
		\label{W234b}
	\end{figure}	
	
	
	In our case, this could have happened if we made a commit on the master branch after creating the other branches.
	
	When this occurs, Git will\textbf{ tie the branch histories together with a new commit. And merge the snapshots at the two branch tips with the most recent common ancestor}, the commit before the divergence. To do this successfully, Git tries to figure out how to combine both snapshots. If the changes were made in different files, or in different parts of the same file, Git will take both changes and put them together in the result. \textbf{If instead the changes are made on the same part of the same file}, Git won't know how to merge those changes, and \textbf{the attempt will result in a merge conflict}. This sounds scary, but don't panic. Git doesn't quit, we'll solve those conflicts in our next video.
	
	\subsection{Merge Conflicts}
	
	From time to time, we might find that both the branches we're trying to merge have edits to the same part of the same file. This will result in something called a \texttt{merge conflict}. Normally, Git can automatically merge files for us. But when we have a \texttt{merge conflict}, it will need a little help to figure out what to do. To see how this would look, let's edit the \verb|free_memory.py| file in the \texttt{master} branch and replace the pass statement with a comment about what the main function should do.
	
	%Code
	\begin{verbatim}
	#Old code
		
		def main():
			pass
		
		main()
		
	#New code
		
		def main():
			"""Checks if there is enough free memory in the computer"""
		
		main()		
	\end{verbatim}
		
	
	Cool, we made the change so let's save it and commit it back to our \texttt{master} branch ().
	
	%Code
	\begin{verbatim}
		git commit -a -m 'Add comment to main()'
	[master fe2fc5b] Add comment to main()
	 1 file changed, 2 insertions(+), 2 deletions(-)		
	\end{verbatim}
	
	Next, Let's \textbf{check out} the \verb|even-better-feature| branch and \textbf{make a change in the same place}. In this case, we will \textbf{replace the call to pass with a call to print}, saying that everything is okay.	Now, we'll save this other change and commit it to this branch.
	
	\begin{verbatim}
	>>	$ git checkout even-better-feature
		Switched to branch 'even-better-feature'
		
	>>  $ atom free_memory.py
	#Old code
		
		def main():
			pass
			
		main()
		
	#New code
		
		def main():
			print("Everything is OK")
		
		main()
	
	>>  $ git commit -a -m 'Print everything ok'
	[even-better-feature ca6de99] Print everything ok'
	 1 file changed, 2 insertions(+), 2 deletions(-)
	\end{verbatim}
	
	We are primed for chaos with our file all setup for a merge conflict. Let's \textbf{check out the} \texttt{master} \textbf{branch} again and \textbf{try to merge the} \verb|even-better-feature| back into it. 
	
	\begin{verbatim}
		>>	$ git checkout master
		Switched to branch 'master'
		
		>>  $ git merge even-better-feature
		Auto-merging free_memory.py
		CONFLICT (content): Merge conflickt in free_memory.py
		Automatic merge failed; fix conflicts and then commit the result.
	\end{verbatim}

	Git tells us it \textbf{tried to automatically merge the two versions} of the \verb|free_memory| file, but \textbf{it didn't know how to do it}. We can use Git's status to get more information about what's going on.
	
	%Code
	\begin{verbatim}
		>>	$ git status
		On branch master
		You have unmerged paths
			(fix conflicts and run "git commit")
			(use "git merge --abort" to abort the merge)
			
		Unmerged paths:
			(use "git add <file>... to mark resolution)

				both modified: free_memory.py
		no changes added to commit (use "git add" and/or "git commit -a")		
	\end{verbatim}
	
	
	As usual, git status gives us a lot of additional information. It tells us that \textbf{we have files that are currently unmerged}, and that \textbf{we need to fix the conflicts or abort the merge if we decide it was a mistake}. It also tells us that we \textbf{need to run} \texttt{Git add} \textbf{on each unmerged file to mark that the conflicts have been resolved}. 
	
	Let's get to work. To fix the conflict, let's open up \verb|free_memory.py| in our text editor.
	
	\begin{verbatim}
		def main():
			
		<<<<<<< HEAD
			"""Checks if there's enough free memory in the computer."""
		=======
			print("Everything is ok.)
		>>>>>>> even-better-feature
		
		main()		
	\end{verbatim}
	
	Thankfully, Git has added some information to our files to tell us which parts of the code are conflicting. The \textbf{unmerged content of the file at head}, remember, in this case, \textbf{head points to master}, is the \textbf{docstring stating what the main function should do}. The unmerged content of the file \textbf{in} the \verb|even-better-feature| branch \textbf{is the call to the print function}. It's up to us to decide which one to keep or if we should change the contents of the file altogether. 
	In this case, \textbf{we'll keep both statements and delete the merger markers}.
	
	\begin{verbatim}
		def main():		
	
			"""Checks if there's enough free memory in the computer."""
			print("Everything is ok.)
		
		main()		
	\end{verbatim}
	
	
	Now that we've fixed the conflict, we'll mark it as resolved by running \texttt{git add} on the file, and then call the \texttt{git status} to see how our merge is doing. 
	
	\begin{verbatim}
		>> $ git add free_memory.py
		>> $ git status
		On branch master
		All conflicts fixed but you are still merging.
			(use "git commit" to conclude merge)
		
		Changes to be committed:
			modifies: free_memory.py
	\end{verbatim}
	
	
	See how Git now tells us that all conflicts have been resolved. Woo-hoo, we just need to call git commit to wrap up the merge (\texttt{git commit}).
	
	The comments that git commit shows us look different than other commits. That's because this is a merge and Git tells us so. It also tells us which file had conflicts which have now been resolved. The commit already has a description saying that it's merging the other branch. This description was automatically created when we called the git merge command. But we can add onto this description if we want. For example, we can say that we're keeping the lines from both branches, and then just save and exit as usual. The merge conflict is resolved. 
	
	To see what the commit history looks like now, we'll use a couple of handy options to the \texttt{git log command}; \verb|--graph| for seeing the commits as a graph, and \verb|--oneline| to only see one line per commit. 
	
	\begin{figure} 
		\caption{Commit Graph}
		\centering
		\includegraphics[scale=0.2]{W2/W235a.png}
		\label{W235a}
	\end{figure}

	This format helps us better understand the history of our commits and how merges have occurred. We can see the new commit (\texttt{8cb5e62}) that was added and also the two separate commits that we merged. One coming from the \texttt{master} branch (\texttt{fe2fc5b}) and the other coming from the \verb|even-better-feature| branch (\texttt{ca6de99}). 
	
	We can also see that \texttt{master} \textbf{is pointing to the merge commit} but \verb|even-better-feature| \textbf{is still pointing to the previous one}. 
	
	In our example, resolving the conflict was straightforward and easy. But in the real world, this won't always be the case. Merge conflicts can sometimes be tricky, complicated, and spread across multiple files. If you want to throw the merge away and start over, you can use the \verb|git merge --abort| command as an escape hatch. This will \textbf{stop the merge and reset the files in your working tree back to the previous commit before the merge ever happened}. So by now you know how to create, delete, and switch between branches in Git. You've also seen that \textbf{each branch represents a pointer to a commit in a sequence of independent snapshots}. You know how to merge these commits back into the main trunk by using the git merge command. Amazing work. Seriously, this isn't easy stuff. Up next, you'll find a cheat sheet summarizing all of these branching techniques followed by a quiz to consolidate these concepts.
	
	\subsection{Reading: Git Branches and Merging Cheat Sheet}

	\begin{itemize}
		\item \verb|git branch| : Used to manage branches.

		\item \verb|git branch <name>| : Creates the branch.
		
		\item \verb|git branch -d <name>| : Deletes the branch.

		\item \verb|git branch -D <name>| : Forcibly deletes the branch.

		\item \verb|git checkout <branch>| : Switches to a branch.

		\item \verb|git checkout -b <branch>| : Creates a new branch and switches to it.
		
		\item \verb|git merge <branch>| : Merge joins branches together.
		
		\item \verb|git merge --abort| :If there are merge conflicts (meaning files are incompatible), \verb|--abort| can be used to abort the merge action..
		
		\item \verb|git log --graph --oneline| : This shows a summarized view of the commit history for a repo.
	\end{itemize}	



